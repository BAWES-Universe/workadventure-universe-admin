generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users
model User {
  id           String   @id @default(uuid())
  uuid         String   @unique // WorkAdventure user identifier
  email        String?  @unique
  name         String?
  matrixChatId String?  @map("matrix_chat_id") // Matrix ID: "@user:matrix.org"
  lastIpAddress String? @map("last_ip_address") // Last known IP address
  isGuest      Boolean  @default(false) @map("is_guest") // True for unauthenticated guest users
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  ownedUniverses    Universe[]        @relation("UniverseOwner")
  worldMemberships  WorldMember[]
  bans              Ban[]             @relation("BannedUser")
  bannedBy          Ban[]             @relation("BannedBy")
  avatars           UserAvatar[]
  favorites         Favorite[]
  followers         Follow[]          @relation("Follower")
  following         Follow[]          @relation("Following")
  friendships1      Friendship[]      @relation("User1")
  friendships2      Friendship[]      @relation("User2")
  requestedFriendships Friendship[]   @relation("RequestedBy")
  roomAccesses      RoomAccess[]

  @@map("users")
}

// Universes
model Universe {
  id          String   @id @default(uuid())
  slug        String   @unique // URL identifier: "my-universe"
  name        String
  description String?
  ownerId     String   @map("owner_id")
  isPublic    Boolean  @default(true) @map("is_public")
  featured    Boolean  @default(false) // For discovery
  thumbnailUrl String? @map("thumbnail_url")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  owner      User      @relation("UniverseOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  worlds     World[]
  bans       Ban[]
  favorites  Favorite[]
  roomAccesses RoomAccess[]

  @@map("universes")
}

// Worlds
model World {
  id          String   @id @default(uuid())
  universeId  String   @map("universe_id")
  slug        String   // URL identifier: "office-world"
  name        String
  description String?
  isPublic    Boolean  @default(true) @map("is_public")
  featured    Boolean  @default(false) // For discovery
  thumbnailUrl String? @map("thumbnail_url")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  universe   Universe     @relation(fields: [universeId], references: [id], onDelete: Cascade)
  rooms      Room[]
  members    WorldMember[]
  bans       Ban[]
  avatars    UserAvatar[]
  favorites  Favorite[]
  roomAccesses RoomAccess[]

  @@unique([universeId, slug]) // Slug unique within universe
  @@map("worlds")
}

// Rooms
model Room {
  id          String   @id @default(uuid())
  worldId     String   @map("world_id")
  slug        String   // URL identifier: "lobby"
  name        String
  description String?
  mapUrl      String?  @map("map_url") // External TMJ URL (e.g., GitHub Pages)
  wamUrl      String?  @map("wam_url") // WAM file URL in map-storage (created via PUT)
  authenticationMandatory Boolean @default(false) @map("authentication_mandatory")
  isPublic    Boolean  @default(true) @map("is_public")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  world      World      @relation(fields: [worldId], references: [id], onDelete: Cascade)
  favorites  Favorite[]
  roomAccesses RoomAccess[]

  @@unique([worldId, slug]) // Slug unique within world
  @@map("rooms")
}

// Room Access Analytics
model RoomAccess {
  id              String   @id @default(uuid())
  userUuid        String?  @map("user_uuid") // UUID from WorkAdventure (ephemeral for guests)
  userId          String?  @map("user_id") // Only set if authenticated user exists
  ipAddress       String   @map("ip_address") // IP address for tracking
  userName        String?  @map("user_name") // Name from request or user record
  userEmail       String?  @map("user_email") // Email from request or user record
  isGuest         Boolean  @default(true) @map("is_guest") // true if unauthenticated
  isAuthenticated Boolean  @default(false) @map("is_authenticated") // true if has OIDC token
  hasMembership   Boolean  @default(false) @map("has_membership") // true if has WorldMember record
  membershipTags  String[] @map("membership_tags") // Tags from membership if exists

  universeId      String   @map("universe_id")
  worldId         String   @map("world_id")
  roomId          String   @map("room_id")

  universeSlug    String   @map("universe_slug")
  worldSlug       String   @map("world_slug")
  roomSlug        String   @map("room_slug")

  playUri         String   @map("play_uri") // Full play URI

  accessedAt      DateTime @default(now()) @map("accessed_at")

  // Relations
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  universe        Universe @relation(fields: [universeId], references: [id], onDelete: Cascade)
  world           World    @relation(fields: [worldId], references: [id], onDelete: Cascade)
  room            Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@index([universeId, accessedAt])
  @@index([worldId, accessedAt])
  @@index([roomId, accessedAt])
  @@index([userId, accessedAt])
  @@index([ipAddress, accessedAt])
  @@index([accessedAt])
  @@map("room_accesses")
}

// World Memberships
model WorldMember {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  worldId   String   @map("world_id")
  tags      String[] // Array of tags: ["admin", "editor", "member"]
  joinedAt  DateTime @default(now()) @map("joined_at")

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  world World @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@unique([userId, worldId])
  @@index([worldId])
  @@index([userId])
  @@map("world_members")
}

// Bans
model Ban {
  id        String    @id @default(uuid())
  userId    String?   @map("user_id")
  universeId String?  @map("universe_id")
  worldId   String?   @map("world_id")
  ipAddress String?   @map("ip_address") // IPv4 or IPv6
  reason    String?
  bannedById String?  @map("banned_by")
  bannedAt  DateTime  @default(now()) @map("banned_at")
  expiresAt DateTime? @map("expires_at") // NULL = permanent
  isActive  Boolean   @default(true) @map("is_active")

  // Relations
  user      User?     @relation("BannedUser", fields: [userId], references: [id], onDelete: Cascade)
  universe  Universe? @relation(fields: [universeId], references: [id], onDelete: SetNull)
  world     World?    @relation(fields: [worldId], references: [id], onDelete: SetNull)
  bannedBy  User?     @relation("BannedBy", fields: [bannedById], references: [id])

  @@index([userId])
  @@index([ipAddress])
  @@index([worldId])
  @@map("bans")
}

// User Avatars & Companions
model UserAvatar {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  worldId         String   @map("world_id")
  textureIds      String[] @map("texture_ids") // Array of texture IDs: ["male1", "hat1"]
  companionTextureId String? @map("companion_texture_id")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  world World @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@unique([userId, worldId])
  @@map("user_avatars")
}

// Favorites (for future social features)
model Favorite {
  id         String    @id @default(uuid())
  userId     String    @map("user_id")
  universeId String?   @map("universe_id")
  worldId    String?   @map("world_id")
  roomId     String?   @map("room_id")
  favoritedAt DateTime @default(now()) @map("favorited_at")

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  universe Universe? @relation(fields: [universeId], references: [id], onDelete: Cascade)
  world    World?   @relation(fields: [worldId], references: [id], onDelete: Cascade)
  room     Room?    @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("favorites")
}

// Follows (for future social features)
model Follow {
  id         String   @id @default(uuid())
  followerId String   @map("follower_id")
  followingId String @map("following_id")
  followedAt DateTime @default(now()) @map("followed_at")

  // Relations
  follower  User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// Friendships (for future social features)
model Friendship {
  id         String    @id @default(uuid())
  user1Id    String    @map("user1_id")
  user2Id    String    @map("user2_id")
  status     String    @default("pending") // pending, accepted, blocked
  requestedById String? @map("requested_by")
  createdAt  DateTime  @default(now()) @map("created_at")
  acceptedAt DateTime? @map("accepted_at")

  // Relations
  user1       User   @relation("User1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2       User   @relation("User2", fields: [user2Id], references: [id], onDelete: Cascade)
  requestedBy User?  @relation("RequestedBy", fields: [requestedById], references: [id])

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@map("friendships")
}
